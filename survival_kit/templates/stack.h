/**
Template stack: a stack implementation based on a singly-linked list of nodes.

It is the caller's responsibility to undefine template parameters after 
#include'ing this file.

See "survival_kit/stack_builtins.h" for stack instantiations of common C builtin
  types, as well as unit tests.

Parameters:

SKIT_T_ELEM_TYPE (required) -
	The type for elements in this list, ex: int, float.
	
SKIT_T_NAMESPACE (optional) -
	The namespace that the instanced stack will live in.
	
	With a SKIT_T_NAMESPACE of foobar, the resulting type will be
	foobar_abc_stack.
	
	This is used when writing libraries to ensure that stack types
	instantiated in the library do not collide with stack types instantiated
	in the library user's code or other libraries that happen to have similar
	element names.
	
	This, along with SKIT_T_NAME, can be about 13 characters long in total.
	Any longer and the symbol names generated by the template could be too
	long for the OpenVMS linker to handle.
	
	By default, this is defined like so:
	#define SKIT_T_NAMESPACE skit

SKIT_T_NAME (required) -
	A unique name that is included in all type/function expansions created by
	this template.  It works like so:
	
	EXAMPLE1:
	#define SKIT_T_ELEM_TYPE int
	#define SKIT_T_NAME int
	#include "survival_kit/templates/stack.h"
	#undefine SKIT_T_ELEM_TYPE
	#undefine SKIT_T_NAME
	skit_int_stack  list;        // The type 'skit_int_stack' is defined.
	skit_int_snode  node;        // The type 'skit_int_snode' is defined.
	node.val = 42;
	skit_int_stack_ctor(&list);        // The function 'skit_int_stack_ctor' is defined.
	skit_int_stack_push(&list,&node);  // The function 'skit_int_stack_push' is defined.
	
	EXAMPLE2:
	#define SKIT_T_ELEM_TYPE my_type_with_a_really_long_name
	#define SKIT_T_NAME my_type
	#include "survival_kit/templates/stack.h"
	#undefine SKIT_T_ELEM_TYPE
	#undefine SKIT_T_NAME
	skit_my_type_stack  list;        // The type 'skit_my_type_stack' is defined.
	skit_my_type_snode  node;        // The type 'skit_my_type_snode' is defined.
	my_type_with_a_really_long_name foo = create_my_type(...);
	node.val = foo;
	skit_my_type_stack_ctor(&list);        // The function 'skit_my_type_stack_ctor' is defined.
	skit_my_type_stack_push(&list,&node);  // The function 'skit_my_type_stack_push' is defined.

SKIT_T_FUNC_ATTR (optional, defaualts to nothing) - 
	Specifies function attributes to be used on all functions created.
	This is mostly present to allow functions to be instanced as 'static' so
	  that they will not cause linking collisions with instances found in
	  different and unrelated files that happen to have the same SKIT_T_NAME.

SKIT_T_DIE_ON_ERROR (optional) - 
	Defining this makes it so that invalid operations cause skit_die(...) to be 
	called instead of raising an exception.
	This is esed by certain places like the feature_emulation.h module where 
	exception throwing can't be used because the lists are being used to 
	implement the ability to throw exceptions.
*/


#ifndef SKIT_T_NAMESPACE
#define SKIT_T_NAMESPACE skit
#define SKIT_T_NAMESPACE_IS_DEFAULT 1
#endif

#include "survival_kit/templates/skit_t.h"

#ifndef SKIT_T_ELEM_TYPE
#error "SKIT_T_ELEM_TYPE is needed but was not defined."
#endif

#include <unistd.h> /* for ssize_t */

typedef struct SKIT_T(stnode) SKIT_T(stnode);
struct SKIT_T(stnode)
{
	SKIT_T_ELEM_TYPE val;
	SKIT_T(stnode) *next;
};

typedef struct SKIT_T(stack) SKIT_T(stack);
struct SKIT_T(stack)
{
	SKIT_T(stnode) *front;
	SKIT_T(stnode) *back;
	ssize_t length;
};

/**
Initializes a list object as a zero-length list. O(1) operation. 
This is an in-place operation.  The result is provided as a return value so
  that this function may appear within expressions.
Returns: The list object that was passed in, initialized to an empty list.
*/
SKIT_T(stack) *SKIT_T(stack_ctor)(SKIT_T(stack) *list);

/** Pushes a stnode onto the front of the list. O(1) operation. */
void SKIT_T(stack_push)(SKIT_T(stack) *list, SKIT_T(stnode) *node);

/** Places a stnode onto the back of the list. O(1) operation. */
void SKIT_T(stack_append)(SKIT_T(stack) *list, SKIT_T(stnode) *node);

/** Pops a stnode from the front of the list. O(1) operation. */
SKIT_T(stnode) *SKIT_T(stack_pop)(SKIT_T(stack) *list);

/**
Does a shallow copy of the given stack.
In other words: it will copy the pointed to stack object, and it will copy
the nodes in the stack, but it will not copy any caller data pointed to by
node contents.
It is the caller's responsibility to free the stack that is allocated by this
operation.
The new stack and its nodes will be allocated with skit_malloc.
This is an O(n) operation.
*/
SKIT_T(stack) *SKIT_T(stack_dup)(SKIT_T(stack) *stack);

/**
Same as stack_dup, but yields a reversed stack. 
This will be faster than calling stack_dup followed by stack_reverse,
because it will only need to make one pass over the stack.
This is an O(n) operation.
*/
SKIT_T(stack) *SKIT_T(stack_rdup)(SKIT_T(stack) *stack);

/**
Walks the stack, calling 'predicate' on each node.
If 'predicate' returns 0, then the walk will abort.
The 'context' variable will be passed directly into the calls on 'predicate'.
'predicate' will not be called on nodes before 'start_node' or after 'end_node'.
If 'start_node' is NULL, the walk will begin at the very beginning of the stack.
If 'start_node' is otherwise not in the stack, then 'predicate' will never be
  be called and an OUT_OF_BOUNDS exception will be thrown. (Currently unimplemented)
If 'end_node' is NULL, the walk will end at the very end of the stack.
If 'end_node' is otherwise not in the stack, then the walk will continue through
  the last node and then throw an OUT_OF_BOUNDS exception. (Currently unimplemented)
If 'end_node' is encountered before 'start_node', then 'predicate' will never
  be called.
*/
void SKIT_T(stack_walk)(
	const SKIT_T(stack) *stack,
	int predicate(void *context, const SKIT_T(stnode) *node),
	void *context,
	const SKIT_T(stnode) *start_node,
	const SKIT_T(stnode) *end_node
);

/**
Reverses the order of elements in the given stack, in-place.
This is an O(n) operation.
*/
void SKIT_T(stack_reverse)( SKIT_T(stack) *stack );

#ifdef SKIT_T_NAMESPACE_IS_DEFAULT
#undef SKIT_T_NAMESPACE
#undef SKIT_T_NAMESPACE_IS_DEFAULT
#endif

